# Architecture Decision Record (ADR): AWS CDK実装

## ADR-001: CDKによるインフラストラクチャのIaC化

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
Live Commentプロジェクトでは、インフラストラクチャのプロビジョニングと管理を効率化し、一貫性を持たせる必要がある。

**決定**:
AWS Cloud Development Kit (CDK) TypeScript版を採用して、インフラストラクチャをコード化する。

**理由**:
- TypeScriptによる型安全性がもたらす開発効率と安全性
- コードとしてのインフラストラクチャ定義により、バージョン管理やレビュープロセスを適用可能に
- 高レベルの抽象化により、大量のCloudFormationテンプレートを書く手間を削減
- 標準的なプログラミング言語を使用することによる柔軟性の向上

**結果**:
インフラの変更履歴が明確になり、開発チームは協調してインフラ開発に取り組めるようになる。また、TypeScriptの型システムにより、設定ミスやエラーを早期に発見できるようになる。

## ADR-002: サーバーレスアーキテクチャの採用

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
Live Commentシステムでは、多くの同時接続を効率的に処理し、コストも抑える必要がある。

**決定**:
Lambda、API Gateway、DynamoDBを中心としたサーバーレスアーキテクチャを採用する。

**理由**:
- スケーラビリティ：トラフィックに応じて自動的にスケールアップ/ダウン
- コスト効率：使用した分だけ支払い、常時稼働するサーバーが不要
- 運用負荷の軽減：サーバー管理が不要
- 開発速度：個別のマイクロサービス機能を独立して開発・デプロイ可能

**結果**:
インフラの管理負荷を最小限に抑えながら、効率的にスケールするシステムを構築できる。特にイベント中の一時的な負荷に強いシステムとなる。

## ADR-003: DynamoDBのデータモデリング

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
リアルタイムコメントシステムでは、部屋情報とコメント情報を効率的に保存・取得する必要がある。

**決定**:
以下のテーブル設計を採用する：
1. RoomsTable: パーティションキーとして`roomId`を使用
2. CommentsTable: パーティションキーとして`roomId`、ソートキーとして`commentId`を使用
3. ConnectionsTable: WebSocket接続を管理するテーブル、GSIで`roomId`による逆引きを可能に

**理由**:
- アクセスパターンの最適化：部屋ごとのコメント取得という主要アクセスパターンにマッチ
- コストとパフォーマンスのバランス：1テーブル設計も検討したが、個別テーブルでの管理がシンプル
- スケーラビリティ：PAY_PER_REQUESTモードでの自動スケーリング

**代替案**:
- シングルテーブル設計：複数エンティティを1つのテーブルに格納
- RDBMSの使用：Aurora Serverlessなどのリレーショナルデータベースの採用

**結果**:
シンプルでありながら、メインのアクセスパターンに最適化されたデータモデルとなる。将来的なデータ量増加にも柔軟に対応できる。

## ADR-004: WebSocketとREST APIの併用

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
リアルタイムコメント配信には双方向通信が必要だが、すべての操作をリアルタイム通信にする必要はない。

**決定**:
- WebSocket API: リアルタイムコメント配信用
- REST API: 部屋作成、部屋一覧取得、コメント履歴取得などの通常操作用

**理由**:
- 適材適所の技術選択：操作の性質に合わせたプロトコル選択
- フロントエンド実装の簡素化：一般的なREST APIとWebSocketの組み合わせで標準的な実装が可能
- リソース効率：持続的な接続が必要ない操作はREST APIで処理

**代替案**:
- すべてWebSocketで実装：双方向通信でリアルタイム性を優先
- GraphQL API: より柔軟なデータ取得

**結果**:
必要な機能をバランスよく実装でき、フロントエンドとの連携もスムーズに行える。

## ADR-005: L2コンストラクトの優先使用

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
CDKでは、L1（低レベル）、L2（中レベル）、L3（高レベル）のコンストラクトが提供されている。適切な抽象化レベルを選択する必要がある。

**決定**:
可能な限りL2コンストラクトを使用し、必要に応じてL1コンストラクトを組み合わせる。

**理由**:
- L2コンストラクトにより、ベストプラクティスが自動的に適用される
- コードの可読性と保守性の向上
- 一般的なユースケースで十分な柔軟性を提供
- L1コンストラクトよりも簡潔なコード

**代替案**:
- すべてL1コンストラクトで実装：より詳細な制御が可能
- L3ソリューションコンストラクトの使用：より高レベルの抽象化

**結果**:
コードの量を削減しつつ、十分な柔軟性とカスタマイズ性を確保できる。

## ADR-006: TypeScriptによるLambda実装

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
Lambda関数の実装言語には複数の選択肢があり、適切な言語を選定する必要がある。

**決定**:
すべてのLambda関数をTypeScriptで実装し、NodejsFunctionコンストラクトを使用してデプロイする。

**理由**:
- 型安全性：実行時エラーを減らし、コード品質を向上
- CDK自体もTypeScriptで書かれており、一貫性がある
- esbuildによる自動バンドル：依存関係の管理が容易に
- コード補完と静的解析のメリット

**代替案**:
- JavaScript：型情報なしで開発速度優先
- Python：データ処理が主要な場合に有利

**結果**:
均質で品質の高いコードベースを維持でき、開発体験が向上する。

## ADR-007: 環境変数による環境分離

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
複数の環境（dev、test、prod）でインフラをデプロイし管理する必要がある。

**決定**:
環境変数（ENVIRONMENT）を使用して環境を区別し、環境ごとに異なるスタック名とリソース名を使用する。

**理由**:
- シンプルさ：環境変数は理解しやすく設定が容易
- CI/CDとの互換性：ほとんどのCI/CDシステムで環境変数の設定が標準的
- 透明性：現在の環境がコード中で明示的に参照される
- 柔軟性：新しい環境の追加が容易

**代替案**:
- CDKコンテキスト：`cdk.json`や`--context`フラグで環境を指定
- AWS Profilesの利用：各環境に別のAWSプロファイルを使用

**結果**:
環境間の分離が明確になり、CI/CDパイプラインでの自動デプロイが容易になる。

## ADR-008: フロントエンドのS3+CloudFrontホスティング

**日付**: 2025-04-19

**ステータス**: 採用

**コンテキスト**:
フロントエンドアプリケーションをホスティングするための最適な方法を決定する必要がある。

**決定**:
S3バケットにフロントエンドの静的アセットを保存し、CloudFrontでコンテンツ配信を行う。

**理由**:
- スケーラビリティ：大量のアクセスにも対応可能
- コスト効率：静的ホスティングのコストが低い
- セキュリティ：S3のパブリックアクセスを無効化し、CloudFrontからのみアクセス可能
- パフォーマンス：エッジロケーションによる低レイテンシー

**代替案**:
- Amplify Hosting：CI/CDが組み込まれた専用ホスティングサービス
- EC2またはECS：より高度な処理が必要な場合

**結果**:
高性能で安全、かつコスト効率の良いフロントエンドホスティングが実現できる。